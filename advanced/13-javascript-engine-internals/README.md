# JavaScript Engine Internals (V8-Centric)

This module focuses on how modern V8 executes JavaScript and why code shape affects optimization.

Scope:
- Parsing -> bytecode -> JIT optimization
- Hidden classes (shapes) and transitions
- Inline caches (ICs)
- Deoptimization triggers with realistic examples

This is intentionally V8-centric. Do not over-generalize details to all engines.

## 1) Execution Pipeline: Parsing -> Ignition -> TurboFan

### Parsing and Early Compilation

V8 starts by parsing source into an internal representation (AST + scope metadata). During this stage it resolves declarations, lexical scope boundaries, and binding rules (`var`/`let`/`const`, function declarations, closures).

Conceptual stages:
1. Source text is tokenized and parsed.
2. Scope and variable metadata are built.
3. Baseline executable form (bytecode) is generated for Ignition.

The parser may do less upfront work for functions that are never called. Exact internals evolve across V8 versions.

### Ignition: Interpreter + Bytecode

Ignition executes bytecode. Bytecode is lower-level than source but higher-level than machine code.

Key idea:
- Ignition starts execution quickly.
- While running, it records feedback about operations (for example: observed receiver shapes at a property load site).

That feedback is later used by TurboFan.

Example command:

```bash
node --print-bytecode script.js
```

Use this to inspect generated bytecode for functions. Output format is V8-internal and unstable.

### TurboFan: Optimizing Compiler

When functions become hot (frequently executed), V8 may optimize them with TurboFan.

Important:
- There is no stable public "exact threshold" you should rely on.
- Hotness and optimization decisions are heuristic and version-dependent.
- Optimization is speculative: it assumes future executions look like past feedback.

### Speculative Optimization

Speculative optimization means:
- V8 observes stable patterns (for example, same receiver shape).
- It generates specialized code for that pattern.
- It inserts guards (checks) to verify assumptions at runtime.

If assumptions fail, optimized code is invalid for current input and V8 deoptimizes.

### What Deoptimization Actually Does

Deoptimization (deopt) is a bailout from optimized machine code back to a less-specialized tier (typically interpreter/baseline state), while preserving JavaScript-observable semantics.

Conceptually:
1. Guard fails in optimized code.
2. V8 reconstructs a valid interpreter frame/state.
3. Execution continues correctly, but slower for that path.

Deopt is correctness-preserving, not correctness-breaking.

## 2) Hidden Classes (Shapes)

### Same properties ≠ same shape (hidden class)

In V8, **hidden classes are created by transitions**, not by “final object equality”.
That means two objects with the same set of properties can still have different shapes if:

- properties are added in a different order,
- the prototype differs,
- properties are deleted and re-added (causing transitions),
- property attributes differ (data vs accessor, enumerable vs non-enumerable).

Example (same properties, different insertion order → different shapes):

```js
function A() {
  this.x = 1;
  this.y = 2;
}

function B() {
  this.y = 2;
  this.x = 1;
}
```

At a hot call site, mixing such objects can push inline caches from **monomorphic** to
**polymorphic**, and can trigger deopts if the optimized code assumed a stable shape.


V8 tracks object layout with hidden classes (often called "maps" or "shapes").

Shape includes layout-relevant metadata such as:
- Which properties exist
- Property addition sequence
- Offsets/layout strategy used for fast access

### Property Addition Order Matters

```js
const a = {};
a.x = 1;
a.y = 2; // shape path: {} -> {x} -> {x,y}

const b = {};
b.y = 2;
b.x = 1; // shape path: {} -> {y} -> {y,x}
```

`a` and `b` end with the same key set, but likely different shapes due to different transition history/order.

### Small Annotated Transition Example

```js
function makePoint(x, y) {
  const p = {};      // Shape S0
  p.x = x;           // S0 -> S1
  p.y = y;           // S1 -> S2
  return p;          // Stable if all instances follow same path
}

function makePointAlt(x, y) {
  const p = {};      // Shape S0
  p.y = y;           // S0 -> S3
  p.x = x;           // S3 -> S4
  return p;          // Different transition chain
}
```

Even though both return `{x, y}` logically, ICs observe different shapes.

### Why Layout Consistency Matters

If many objects used at one call site share one shape, V8 can generate specialized fast paths.

If shapes vary heavily:
- ICs become polymorphic/megamorphic.
- Specialized code is less effective.
- Deopt probability increases under speculation.

### Monomorphic vs Polymorphic Call Sites

At a property access site like `obj.x`:
- Monomorphic: one observed shape
- Polymorphic: a small set of shapes
- Megamorphic: many shapes; generic slow path likely

## 3) Inline Caches (ICs)

An inline cache records runtime type/shape feedback for an operation at a specific bytecode location.

Common IC categories include:
- Load IC (`obj.prop`)
- Store IC (`obj.prop = value`)
- Call IC (`fn(...)` / method calls)

Typical state progression (conceptual):
- Uninitialized
- Monomorphic
- Polymorphic
- Megamorphic

### Relationship Between ICs and Hidden Classes

ICs usually key off receiver shapes.

Example:

```js
function readX(o) {
  return o.x; // One IC site
}

readX({ x: 1 });
readX({ x: 2 });
// Same shape -> monomorphic likely

readX({ y: 1, x: 2 });
// Additional shape at same site -> polymorphic pressure
```

Stable shape usage keeps ICs specialized and predictable.

## 4) Deoptimization Triggers (Realistic Patterns)

These patterns frequently cause optimization instability. Impact varies by V8 version, but the risk model is stable enough for interviews.

### A) Adding Properties After Initial Construction

```js
function makeUser(id) {
  return { id, score: 0 };
}

const u = makeUser(1);
u.extra = true; // Late shape change
```

If this happens inconsistently across instances, call sites become polymorphic.

### B) Deleting Properties

```js
function clearCache(o) {
  delete o.cache;
  return o;
}
```

`delete` often disrupts fast-property assumptions and can force slower object modes.

### C) Changing Property Value Kinds Repeatedly

```js
function flipType(o, flag) {
  o.value = flag ? 42 : 'forty-two';
  return o.value;
}
```

Frequent type switches increase speculative risk and can invalidate optimized paths.

### D) Switching Argument Types at Hot Sites

```js
function add1(x) {
  return x + 1;
}

add1(41);
add1('41'); // Different semantics and feedback profile
```

Mixed type feedback can prevent or undo specialization.

### E) `try/catch` in Hot Functions

```js
function hotWithCatch(arr) {
  let sum = 0;
  try {
    for (let i = 0; i < arr.length; i++) sum += arr[i];
  } catch (e) {
    return -1;
  }
  return sum;
}
```

Modern V8 is better than old versions, but exception-heavy paths and mixed behavior still pressure optimization.

### F) Accessing the `arguments` Object

```js
function legacy(a, b) {
  return arguments[0] + arguments[1];
}
```

`arguments` can complicate aliasing and optimization compared with explicit parameters/rest args.

### G) Dynamic Property Access Patterns

```js
function readDynamic(obj, key) {
  return obj[key];
}
```

If `key` and receiver shapes vary significantly, IC quality degrades.

## 5) Node/V8 Inspection Tools

These are useful for study, not for production contracts.

### `--trace-opt`

```bash
node --trace-opt script.js
```

Shows optimization attempts and compiled functions.

### `--trace-deopt`

```bash
node --trace-deopt script.js
```

Shows deoptimization events and bailout reasons.

### `--print-bytecode`

```bash
node --print-bytecode script.js
```

Prints Ignition bytecode.

### `--allow-natives-syntax`

```bash
node --allow-natives-syntax script.js
```

Allows V8 intrinsics (example: `%DebugPrint(obj)`).

Example:

```js
// Requires --allow-natives-syntax
const o = { x: 1, y: 2 };
// eslint-disable-next-line no-undef
%DebugPrint(o);
```

Warning:
- Intrinsics are V8-only, unsupported in standard JS, and can change or disappear.
- Never treat them as portable APIs.

## 6) Interview Mental Models

### What to Say About V8 Optimization

Good concise framing:
1. V8 starts with interpreted bytecode (Ignition).
2. Runtime feedback (IC + type/shape observations) guides TurboFan specialization.
3. Optimization is speculative and guarded.
4. Violated assumptions trigger deopt.

### Safe vs Unsafe Claims

Safe:
- Stable object layouts usually help property access performance.
- Consistent input types usually help specialization.
- Heavy shape churn and dynamic access patterns often hurt predictability.

Unsafe:
- "This exact code is always faster in every V8 version."
- "The optimization threshold is exactly N calls."
- "This intrinsic behavior is guaranteed by the ECMAScript spec."

### Why Micro-benchmarks Mislead

Micro-benchmarks often:
- Warm up differently than real workloads.
- Measure optimized steady-state but ignore deopt churn.
- Hide allocation pressure, GC effects, and mixed production inputs.

Always validate with production-like traffic and profiles.

### When Performance Tradeoffs Matter

Prioritize readability first unless:
- Code is in a known hot path (high CPU share).
- Profiling identifies it as bottleneck.
- Latency/throughput SLOs are at risk.

Then optimize with measurement, not folklore.

## 7) Practical Exercise Mindset

For this module's exercises, think in terms of:
- Shape signatures, not just key presence
- IC state transitions at one call site
- Static risk pattern detection for likely deopt hazards
- Deterministic reasoning rather than timing benchmarks
